<script lang="ts" module>
	/**
	 * Options for automatic reconnection.
	 */
	export interface ReconnectOptions {
		/** Whether automatic reconnection is enabled */
		enabled: boolean;

		/** Delay in milliseconds before attempting to reconnect */
		delay: number;

		/** Maximum number of reconnection attempts before giving up */
		maxAttempts: number;
	}

	/**
	 * Configuration options for creating a new SvelteSocket instance.
	 */
	export interface SocketConstructorArgs {
		/** The WebSocket server URL to connect to (e.g., 'ws://localhost:8080') */
		url: string;

		/** Optional callback fired when a message is received from the server */
		onMessage?: (messageEvent: MessageEvent) => void;

		/** Optional callback fired when the WebSocket connection is established */
		onOpen?: (openEvent: Event) => void;

		/** Optional callback fired when the WebSocket connection is closed */
		onClose?: (closeEvent: CloseEvent) => void;

		/** Optional callback fired when a WebSocket error occurs */
		onError?: (errorEvent: Event) => void;

		/** Optional flag to enable debug console logging. Default: false */
		debug?: boolean;

		/** Optional configuration for automatic reconnection */
		reconnectOptions?: ReconnectOptions;
	}

	/**
	 * A reactive WebSocket wrapper using Svelte 5 runes.
	 *
	 * @property {WebSocket['readyState']} connectionStatus - Current connection state (CONNECTING, OPEN, CLOSING, CLOSED)
	 * @property {Array<{message: string, timestamp: number}>} sentMessages - Reactive array of sent messages
	 * @property {Array<{message: MessageEvent}>} receivedMessages - Reactive array of received messages (stores MessageEvent objects)
	 *
	 * @example
	 * Basic usage:
	 * ```typescript
	 * const socket = new SvelteSocket({
	 *   url: 'ws://localhost:8080',
	 *   onMessage: (event) => console.log(event.data),
	 *   onOpen: () => console.log('Connected!')
	 * });
	 *
	 * socket.sendMessage('Hello, Server!');
	 *
	 * // Access received messages
	 * socket.receivedMessages.forEach(({ message }) => {
	 *   console.log(message.data, message.origin);
	 * });
	 * ```
	 *
	 * @example
	 * With auto-reconnect:
	 * ```typescript
	 * const socket = new SvelteSocket({
	 *   url: 'ws://localhost:8080',
	 *   debug: true,
	 *   reconnectOptions: {
	 *     enabled: true,
	 *     delay: 1000,
	 *     maxAttempts: 5
	 *   }
	 * });
	 * ```
	 */
	export class SvelteSocket {
		private socket = $state<WebSocket>();
		private onMessageEvent = $state<((messageEvent: MessageEvent) => void) | undefined>(undefined);
		private onOpenProp = $state<((openEvent: Event) => void) | undefined>(undefined);
		private onCloseProp = $state<((closeEvent: CloseEvent) => void) | undefined>(undefined);
		private onErrorProp = $state<((errorEvent: Event) => void) | undefined>(undefined);
		public connectionStatus = $state<WebSocket['readyState']>(WebSocket.CLOSED);
		public sentMessages = $state<Array<{ message: string; timestamp: number }>>([]);
		public receivedMessages = $state<Array<{ message: MessageEvent }>>([]);
		private debug = $state(false);
		private reconnectOptions = $state<ReconnectOptions | undefined>(undefined);

		// Reconnection state
		private url: string = '';
		private reconnectAttempts = $state(0);
		private reconnectTimeoutId: ReturnType<typeof setTimeout> | null = null;
		private intentionalClose = false; // Flag to prevent reconnection on manual close
		/**
		 * Creates a new SvelteSocket instance and establishes the WebSocket connection.
		 *
		 * @param {SocketConstructorArgs} options - Configuration options for the socket
		 * @param {string} options.url - The WebSocket server URL to connect to
		 * @param {(messageEvent: MessageEvent) => void} [options.onMessage] - Optional callback fired when a message is received
		 * @param {(openEvent: Event) => void} [options.onOpen] - Optional callback fired when the connection opens
		 * @param {(closeEvent: CloseEvent) => void} [options.onClose] - Optional callback fired when the connection closes
		 * @param {(errorEvent: Event) => void} [options.onError] - Optional callback fired when an error occurs
		 * @param {boolean} [options.debug=false] - Enable debug console logging
		 * @param {ReconnectOptions} [options.reconnectOptions] - Auto-reconnection configuration
		 */
		constructor({
			url,
			onMessage,
			onOpen,
			onClose,
			onError,
			debug = false,
			reconnectOptions = undefined
		}: SocketConstructorArgs) {
			this.url = url;
			this.onMessageEvent = onMessage;
			this.onOpenProp = onOpen;
			this.onCloseProp = onClose;
			this.onErrorProp = onError;
			this.debug = debug;
			this.reconnectOptions = reconnectOptions;
			this.createSocket(url);
		}

		/**
		 * Adds an event listener to the WebSocket connection.
		 *
		 * @param {'message' | 'close' | 'open' | 'error'} event - The event type to listen for
		 * @param {(event: Event) => void} callback - The callback function to execute when the event occurs
		 * @throws {Error} If the socket is not connected
		 */
		public addEventListener(
			event: 'message' | 'close' | 'open' | 'error',
			callback: (event: Event) => void
		) {
			if (!this.socket) {
				throw new Error('Socket not connected');
			}
			this.socket.addEventListener(event, callback);
		}

		/**
		 * Removes an event listener from the WebSocket connection.
		 *
		 * @param {'message' | 'close' | 'open' | 'error'} event - The event type
		 * @param {(event: Event) => void} callback - The callback function to remove
		 */
		public removeEventListener(
			event: 'message' | 'close' | 'open' | 'error',
			callback: (event: Event) => void
		) {
			if (this.socket) {
				this.socket.removeEventListener(event, callback);
			}
		}

		/**
		 * Sends a message through the WebSocket connection and stores it in the message history.
		 *
		 * @param {string} message - The message to send
		 * @throws {Error} If the socket is not connected or not in OPEN state
		 */
		public sendMessage(message: string): void {
			if (!this.socket) {
				throw new Error('Socket not connected');
			}
			if (this.socket.readyState !== WebSocket.OPEN) {
				throw new Error('Socket is not in OPEN state');
			}

			this.socket.send(message);
			this.sentMessages.unshift({
				message,
				timestamp: Date.now()
			});
		}

		/**
		 * Clears the sent messages history.
		 */
		public clearSentMessages(): void {
			this.sentMessages = [];
		}

		/**
		 * Attempts to reconnect to the WebSocket server.
		 * @private
		 */
		private attemptReconnect(): void {
			// Don't reconnect if close was intentional
			if (this.intentionalClose) {
				return;
			}

			if (
				!this.reconnectOptions?.enabled ||
				this.reconnectAttempts >= this.reconnectOptions.maxAttempts
			) {
				return;
			}

			this.reconnectAttempts++;

			this.reconnectTimeoutId = setTimeout(() => {
				this.createSocket(this.url);
			}, this.reconnectOptions.delay);
		}

		/**
		 * Creates and connects a new WebSocket connection.
		 * Sets up internal event listeners for open, close, error, and message events.
		 * If a socket already exists, it will be closed before creating a new one.
		 * Automatic reconnection is handled via the attemptReconnect method on close events.
		 *
		 * @param {string} url - The WebSocket server URL to connect to
		 * @private
		 */
		private createSocket(url: string): void {
			// Reset intentional close flag when creating/reconnecting
			this.intentionalClose = false;

			if (this.socket) {
				if (this.debug) {
					console.log('⚠️ SvelteSocket already exists, closing existing connection');
				}
				this.removeSocket();
			}
			this.connectionStatus = WebSocket.CONNECTING;
			this.socket = new WebSocket(url);

			this.socket.addEventListener('open', (event) => {
				this.connectionStatus = WebSocket.OPEN;
				this.reconnectAttempts = 0;
				if (this.reconnectTimeoutId) clearTimeout(this.reconnectTimeoutId);
				this.onOpenProp?.(event);
			});

			this.socket.addEventListener('close', (closeEvent: CloseEvent) => {
				this.connectionStatus = WebSocket.CLOSED;
				this.onCloseProp?.(closeEvent);
				this.attemptReconnect();
			});

			this.socket.addEventListener('error', (errorEvent: Event) => {
				if (this.debug) {
					console.error('🔌 SvelteSocket error:', errorEvent);
				}
				this.onErrorProp?.(errorEvent);
			});

			this.socket.addEventListener('message', (messageEvent: MessageEvent) => {
				if (this.debug) {
					console.log('🔌 SvelteSocket message:', messageEvent.data);
				}
				this.receivedMessages.unshift({
					message: messageEvent
				});
				this.onMessageEvent?.(messageEvent);
			});

			if (this.debug) {
				console.log('🔌 SvelteSocket created', this.socket);
			}
			return;
		}

		/**
		 * Closes the WebSocket connection and prevents reconnection.
		 */
		public removeSocket(): void {
			// Set flag to prevent reconnection when close event fires
			this.intentionalClose = true;

			// Clear any pending reconnection timeout
			if (this.reconnectTimeoutId) {
				clearTimeout(this.reconnectTimeoutId);
				this.reconnectTimeoutId = null;
			}

			if (this.socket) {
				this.connectionStatus = WebSocket.CLOSING;
				this.socket.close();
				this.connectionStatus = WebSocket.CLOSED;
				this.socket = undefined;

				// Clear message history
				this.sentMessages = [];
				this.receivedMessages = [];
			}

			// Reset reconnection attempts
			this.reconnectAttempts = 0;
		}
	}
</script>
